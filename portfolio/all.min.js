'use strict';

var portfolio = angular.module('portfolio', ['ngAnimate', 'ngSanitize', 'mobile-angular-ui', 'mobile-angular-ui.gestures.drag', 'mobile-angular-ui.gestures.touch', 'ngAnimate', 'ngSanitize', 'duScroll'])
// these values are configuration settings for angular-scroll
// .value('duScrollEasing', x => {
// 	return 1-x;
// })
.value('duScrollOffset', 88);
portfolio.factory('landingService', ['$q', function ($q) {

	// rendered the box
	var _renderedBox = $q.defer();

	// animated the B
	var _animatedB = $q.defer();
	// animatedB.promise.then(console.log('resolved animatedB'));

	// created the squares
	var createdSquares = $q.defer();

	// finished animating B and creating squares, so animate the squares
	var requiredForAnimatingSquares = [_animatedB.promise, createdSquares.promise];

	// animated squares
	var animatedSquares = $q.defer();

	// animated explosion
	var _animatedExplosion = $q.defer();

	// animated landing card
	var _animatedCard = $q.defer();

	return {
		'renderedBox': function renderedBox() {
			return _renderedBox.resolve();
		},
		'canShowBox': function canShowBox() {
			return _renderedBox.promise;
		},
		'animatedB': function animatedB() {
			return _animatedB.resolve();
		},
		// 'createdSquares': () => {
		// 	return createdSquares.resolve();
		// },
		// 'canAnimateSquares': () => {
		// 	return $q.all(requiredForAnimatingSquares);
		// },
		// 'animatedSquares': () => {
		// 	return animatedSquares.resolve();
		// },
		'canAnimateExplosion': function canAnimateExplosion() {
			return _animatedB.promise;
		},
		'animatedExplosion': function animatedExplosion() {
			return _animatedExplosion.resolve();
		},
		'canAnimateCard': function canAnimateCard() {
			// return animatedSquares.promise;
			return _animatedExplosion.promise;
		},
		'animatedCard': function animatedCard() {
			return _animatedCard.resolve();
		},
		'canAnimateControls': function canAnimateControls() {
			return _animatedCard.promise;
		}
	};
}]);
portfolio.factory('projectsService', ['$q', '$http', '$rootScope', 'landingService', '$timeout', function ($q, $http, $rootScope, landingService, $timeout) {

	// using rootScope and doing $http over here because doesnt work in controller
	landingService.canAnimateCard().then(function () {

		$timeout(function () {
			$http.get('resources/json/projects.json').then(function (response) {
				$rootScope.projects = response.data;
			});
		}, 888);
	});

	var _cardCount = 0;
	var _activeCard = null;

	return {
		cardCount: function cardCount() {
			return _cardCount;
		},
		activeCard: function activeCard() {
			return _activeCard;
		},
		addCard: function addCard() {
			var newId = _cardCount++;
			_activeCard = _cardCount === 1 ? newId : _activeCard;
			return newId;
		},
		next: function next() {
			_activeCard = _activeCard || 0;
			_activeCard = _activeCard === _cardCount - 1 ? 0 : _activeCard + 1;
		},
		prev: function prev() {
			_activeCard = _activeCard || 0;
			_activeCard = _activeCard === 0 ? _cardCount - 1 : _activeCard - 1;
		},
		cardSpreadInterval: function cardSpreadInterval() {
			//cards take up 95% height, so space is 5%
			var cardSpreadInterval = document.querySelector('.cards-inner').clientHeight * .05 / (_cardCount - 1);
			if (_cardCount > 0) return cardSpreadInterval;
		}

	};
}]);
portfolio.controller('BoxController', ['$scope', 'landingService', function ($scope, landingService) {
	var vm = this;
	$scope.shown = 'front';

	landingService.canAnimateCard().then(function () {
		document.querySelector('.front.shown').classList += ' bg-dark';
	});

	var vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0) - 4;
	var vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0) - 4;

	var boxContainerStyle = document.getElementById('box-container').style;
	boxContainerStyle.width = vw + 'px';
	boxContainerStyle.height = vh + 'px';

	var translateZ = vw / 2 + 'px';
	var box = document.getElementById('box');
	box.style.transform = 'translateZ(-' + translateZ + ') rotateY(0deg)';

	var sides = ['front', 'right', 'back', 'left'];
	this.sides = sides;

	for (var i = sides.length - 1; i >= 0; i--) {
		var rotateY;
		switch (sides[i]) {
			case 'front':
				rotateY = '0deg';
				break;
			case 'right':
				rotateY = '90deg';
				break;
			case 'back':
				rotateY = '180deg';
				break;
			case 'left':
				rotateY = '-90deg';
				break;
		}
		var side = document.querySelector('#box .' + sides[i]);
		side.style.transform = 'rotateY(' + rotateY + ') translateZ(' + translateZ + ')';
		side.style.width = vw + 'px';
		side.style.height = vh + 'px';
	}
	landingService.renderedBox();

	vm.showSide = function (side) {
		document.querySelector('#side-controls a:last-child').style.animationName = 'none';

		var leftControl = document.querySelector('#side-controls a:first-child');
		var rightControl = document.querySelector('#side-controls a:last-child');

		leftControl.style.opacity = '1';
		rightControl.style.opacity = '1';

		var rotateY;
		switch (side) {
			case 'front':
				leftControl.style.opacity = 0;
				rotateY = '0deg';
				break;
			case 'right':
				rotateY = '-90deg';
				break;
			case 'back':
				rotateY = '-180deg';
				break;
			case 'left':
				rightControl.style.opacity = 0;
				rotateY = '-270deg';
				break;
		}
		$scope.shown = side;
		box.style.transform = 'translateZ(-' + translateZ + ') rotateY(' + rotateY + ')';
	};
}]);
// portfolio.controller('LandingController', function($scope, landingService, ){

// });
// portfolio.controller('PortfolioController', [
// 	'$scope',
// 	'$http',
// 	'$window',
// 	'projectsService',
// 	'$location',
// 	'$anchorScroll',
// 	'$document', /*"uiGmapGoogleMapApi", "ColorService", 'ScrollService',*/
// 	'$rootScope',
// 	function($scope, $http, $window, projectsService, $location, $anchorScroll, $document, $rootScope /*, uiGmapGoogleMapApi, ColorService, ScrollService*/) {
// 		var self = this;

// 		$scope.projects = [];
// 		// ProjectsService.loadProjectsInto($scope.projects);
// 		$scope.renderCards= false;
// 		// $http.get('resources/json/projects.json')
// 		// 	.then(response => {
// 		// 		// console.log(response.data);
// 		// 		console.log('loading');
// 		// 		$scope.projects = response.data;
// 		// 		// projectsService.loadedProjects();
// 		// 		// $scope.renderCards = true;
// 		// 	});

// 		// projectsService.loadProjects()
// 		// projectsService.canAddToScope().then(() => {
// 		// 	$scope.projects = projectsService.projects();
// 		// 	console.log($scope.projects);
// 		// });

// 		// projectsService.projects().then(() => {
// 		// 	// $rootScope.projects =
// 		// 	console.log(this);
// 		// });
// 		// console.log($rootScope.projects);
// 		$rootScope.$watch('projects', () => {
// 			console.log('updated');
// 			console.log($rootScope.projects);
// 		});

// 		var birthdate = moment("1993-08-24 00:00").startOf('minute');
// 		this.ageyears = moment().diff(birthdate, 'years');
//         this.agemonths = moment().subtract(this.ageyears, 'years').diff(birthdate, 'months');
//         this.ageseconds = moment().subtract(this.ageyears, 'years').subtract(this.agemonths, 'months').diff(birthdate, 'seconds');
//         setInterval(() => $scope.$apply(() =>
//             this.ageseconds++ //make me older by a second every second
//         ), 1000);

// 		$scope.goToSecond = () => {
// 			// $location.hash('second');
// 			// $anchorScroll();
// 			$document.scrollToElementAnimated(angular.element(document.getElementById('second')));
// 		}

// 		$scope.showLandingContent = false;
// 		$scope.scrollable = 'scrollable';
// 		this.scrollableToggle = state => {
// 			$scope.scrollable = state ? 'scrollable' : 'unscrollable';
// 			// console.log($scope.scrollable);
// 		}

// 		angular.element($window).bind( //when user reaches bottom of page
// 			"scroll",
// 	 		function() {
// 				var windowHeight = "innerHeight" in window ? window.innerHeight : document.documentElement.offsetHeight;
// 				var body = document.body, html = document.documentElement;
// 				var docHeight = Math.max(body.scrollHeight,
// 						body.offsetHeight, html.clientHeight,
// 						html.scrollHeight, html.offsetHeight);
// 				var windowBottom = windowHeight + window.pageYOffset;
// 				if (windowBottom >= docHeight) {
// 					// alert('bottom reached');
// 					console.log('bottom reached');
// 					// self.scrollableToggle(false);
// 				}
// 			}
// 		);

// 		// var gottem = false;
// 		// $http.get('resources/json/items.json')
// 		// 	.then(response => {
// 		// 		// $scope.projects
// 		// 		// if(gottem === false){
// 		// 		// 	console.log(response.data);
// 		// 		// 	gottem = true;	
// 		// 		// }
// 		// 		setTimeout(() => {
// 		// 			console.log(response.data);
// 		// 			console.log('finished');
// 		// 		}, 5555);

// 		// 	});
// 		// $http({
// 		// 	method: 'GET',
// 		// 	url: 'resources/json/items.json'
// 		// }).then(function successCallback(response) {
// 		// 	// this callback will be called asynchronously
// 		// 	// when the response is available
// 		// 	console.log('success',response.data);
// 		// }, function errorCallback(response) {
// 		// 	// called asynchronously if an error occurs
// 		// 	// or server returns response with an error status.
// 		// 	console.log('error',response.data);
// 		// });
// 		// $http({
// 		// 	method: 'GET',
// 		// 	url: 'resources/json/items.json'
// 		// }).success((data,status) => {
// 		// 	console.log('success',data);
// 		// }).error((data,status) => {
// 		// 	console.log('error',data);
// 		// });

// 	}
// ]);
portfolio.controller('PortfolioController', ['$scope', '$http', '$window', '$timeout', 'projectsService', 'landingService', '$location', '$anchorScroll', '$document', /*"uiGmapGoogleMapApi", "ColorService", 'ScrollService',*/
'$rootScope', function ($scope, $http, $window, $timeout, projectsService, landingService, $location, $anchorScroll, $document, $rootScope /*, uiGmapGoogleMapApi, ColorService, ScrollService*/) {

	$scope.showLandingContent = false;
	$scope.scrollable = 'unscrollable';
	this.scrollableToggle = function (state) {
		$scope.scrollable = state ? 'scrollable' : 'unscrollable';
	};

	// @TODO: get scope to update OR figure out why apply/watch is getting called twice in a row
	// @TODO: at least refactor this code into a service
	this.closeActionMenu = function () {
		$scope.actionMenuOpened = false;
		document.querySelector('#action-button input').checked = false;
		document.getElementById('box-container').classList.remove('open-menu-blur');
		document.querySelector('#side-controls a:first-child').style.left = 0;
		document.querySelector('#side-controls a:last-child').style.right = 0;
	};

	$scope.actionMenuOpened = false;

	// $scope.enableCards = 'cardsDisabled';
	// angular.element($window).bind( //when user reaches bottom of page
	// 	"scroll",
	// 		function() {
	// 		var windowHeight = "innerHeight" in window ? window.innerHeight : document.documentElement.offsetHeight;
	// 		var body = document.body, html = document.documentElement;
	// 		var docHeight = Math.max(body.scrollHeight,
	// 				body.offsetHeight, html.clientHeight,
	// 				html.scrollHeight, html.offsetHeight);
	// 		var windowBottom = windowHeight + window.pageYOffset;
	// 		if (windowBottom >= docHeight) {
	// 			console.log('bottom reached');
	// 			$scope.enableCards = 'cardsEnabled';
	// 		}
	// 	}
	// );
}]);
portfolio.directive('actionMenuButton', ['$timeout', function ($timeout) {
	return {
		controller: 'PortfolioController',
		link: function link(scope, element, attrs, PortfolioController) {

			var box = document.getElementById('box-container');

			element.bind('click', function () {
				// element.toggleClass('open');

				$timeout(function () {
					PortfolioController.actionMenuOpened = element[0].querySelector('input').checked ? true : false;

					if (PortfolioController.actionMenuOpened) {
						if (!box.classList.contains('open-menu-blur')) {
							box.classList.add('open-menu-blur');
							element[0].classList.add('open');
						}
						document.querySelector('#side-controls a:first-child').style.left = '-88vw';
						document.querySelector('#side-controls a:last-child').style.right = '-88vw';
					} else if (!PortfolioController.actionMenuOpened) {
						if (box.classList.contains('open-menu-blur')) {
							box.classList.remove('open-menu-blur');
							element[0].classList.remove('open');
						}
						document.querySelector('#side-controls a:first-child').style.left = 0;
						document.querySelector('#side-controls a:last-child').style.right = 0;
					}

					// document.getElementById('box-container').classList.toggle('open-menu-blur');
				});

				// if(element.find('input'))
				// console.log(PortfolioController);
				// angular.element(document.getElementById('box-container')).toggleClass('open-menu-blur');
				// console.log(scope.actionMenuOpened);
				// scope.$watch('actionMenuOpened', (newval, oldval) => {
				// 	scope.$apply(() => {
				// 		scope.actionMenuOpened = newval;
				// 	});
				// });

				// console.log('togg');
				// document.getElementById('box-container').classList.toggle('open-menu-blur');
			});
		}
	};
}]);
portfolio.directive('actionMenuItemButton', ['$timeout', function ($timeout) {
	return {
		link: function link(scope, element, attrs) {
			element.bind('click', function () {
				$timeout(function () {
					scope.actionMenuOpened = false;
				});
			});
		}
	};
}]);
portfolio.directive('animejsBanner', ['$q', 'landingService', function ($q, landingService) {
	return {
		restrict: 'AE',
		templateUrl: 'js/directives/animejs-banner/animejs-banner.html',
		controller: 'PortfolioController',
		transclude: true,
		link: function link(scope, element, attr, ctrl) {

			// animate the B
			var loadingSquares = element[0].querySelector('#loading-squares');
			landingService.canShowBox().then(function () {
				document.getElementById('box-container').className += 'show-box';
				anime({
					targets: '#Bsvg path',
					strokeDashoffset: {
						easing: 'easeInExpo',
						duration: 500,
						// duration: (el, i) => {
						// 	return 88 + (i * 22);
						// },
						value: function value(el) {
							var pathLength = el.getTotalLength();
							el.setAttribute('stroke-dasharray', pathLength);
							return [-pathLength, 0];
						}
					},
					stroke: {
						value: function value(el, i) {
							return 'rgb(' + i * 2 + ',' + i * 8 + ',' + i * 12 + ')';
						},
						easing: 'linear',
						duration: 222
					},
					strokeWidth: {
						value: 8,
						easing: 'linear',
						delay: function delay(el, i) {
							return 222 + i * 22;
						},
						duration: 222
					},
					opacity: {
						value: [0, 1],
						duration: 250,
						delay: 250,
						easing: 'linear'
					},
					delay: function delay(el, i) {
						return i * 30;
					},
					duration: 1200,
					easing: 'easeOutExpo',
					loop: false,
					direction: 'alternate',
					update: function update(animation) {
						// // start animating squares once B is loaded
						// if(animation.reversed==true)
						// 	landingService.animatedB();
						// landingService.animatedB();
					},
					complete: function complete() {
						// console.log('finished loadingscreen');
						landingService.animatedB();
					}
				});
			});

			// // create the elements for the squares
			// var squares = element[0].querySelector('#squares');
			// var x, y, xmax, ymin, xincrement, yincrement;
			// x = y = xmax = ymin = 0;
			// var size = Math.min(Math.ceil(element.height()/3.8), 122);
			// xincrement = yincrement = size; //width and height of each square
			// do {
			// 	squares.innerHTML +=	`
			// 								<article style="width:`+xincrement+`px;height:`+yincrement+`px;top:`+y+`px;right:`+x+`px">
			// 									<div></div>
			// 								</article>
			// 							`;

			// 	if (x < xincrement || y > element.height()-yincrement) {
			// 		if (xmax < element.width()) {
			// 			xmax += xincrement;
			// 		} else {
			// 			ymin += yincrement;
			// 		}
			// 		y = ymin;
			// 		x = xmax;
			// 	} else {
			// 		x -= xincrement;
			// 		y += yincrement;
			// 	}
			// } while (x < element.width() || y < element.height())
			// document.getElementById('squares').style.display = block;
			// landingService.createdSquares();

			// // B is animated AND squares are created
			// landingService.canAnimateSquares().then(() => {
			// 	anime({
			// 		targets: '#squares div',
			// 		rotate: {
			// 			value: 180,
			// 			duration: 888,
			// 			easing: 'linear'
			// 		},
			// 		scale: {
			// 			value: [0, 1],
			// 			// delay: 150,
			// 			duration: 888,
			// 			easing: 'easeInOutExpo'
			// 		},
			// 		loop: false,
			// 		direction: 'normal',
			// 		borderRadius: {
			// 			value: 0,
			// 			duration: 1222,
			// 			easing: 'linear'
			// 		},
			// 		backgroundColor: '#18212D',
			// 		delay: (el, index, total) => {
			// 			var duration = 888; //duration of squares animation
			// 			return index * (duration / total);
			// 		},
			// 		update: (animation) => {
			// 			if(animation.progress > 75)
			// 				landingService.animatedSquares();
			// 		},
			// 		complete: () => {
			// 			squares.className += 'bg-dark';
			// 			element.find('article').hide();
			// 		}
			// 	});
			// });
		}
	};
}]);

portfolio.directive('animejsExplosion', ['$q', 'landingService', '$timeout', function ($q, landingService, $timeout) {
	return {
		restrict: 'AE',
		template: '<canvas id="animejs-explosion"></canvas>',
		controller: 'PortfolioController',
		link: function link(scope, element, attr, ctrl) {

			landingService.canAnimateExplosion().then(function () {

				$timeout(function () {
					var c = document.getElementById("animejs-explosion");
					var ctx = c.getContext("2d");
					var cH;
					var cW;
					var bgColor = "transparent";
					var animations = [];
					var circles = [];

					function removeAnimation(animation) {
						removeClickListeners();
						// element.remove();
						var index = animations.indexOf(animation);
						if (index > -1) animations.splice(index, 1);

						landingService.animatedExplosion();
					}

					function calcPageFillRadius(x, y) {
						var l = Math.max(x - 0, cW - x);
						var h = Math.max(y - 0, cH - y);
						return Math.sqrt(Math.pow(l, 2) + Math.pow(h, 2));
					}

					function addClickListeners() {
						document.addEventListener("touchstart", handleEvent);
						document.addEventListener("mousedown", handleEvent);
					};

					function removeClickListeners() {
						document.removeEventListener("touchstart", handleEvent);
						document.removeEventListener("mousedown", handleEvent);
					};

					function handleEvent(e) {
						if (e.touches) {
							e.preventDefault();
							e = e.touches[0];
						}
						var currentColor = "#3cf0ff";
						var nextColor = "#18212D";
						var targetR = calcPageFillRadius(e.pageX, e.pageY);
						var rippleSize = Math.min(200, cW * .4);
						var minCoverDuration = 750;

						var pageFill = new Circle({
							x: e.pageX,
							y: e.pageY,
							r: 0,
							fill: "#18212D"
						});
						var fillAnimation = anime({
							targets: pageFill,
							r: targetR,
							duration: Math.max(targetR / 2, minCoverDuration),
							easing: "easeOutQuart",
							complete: function complete() {
								bgColor = pageFill.fill;
								removeAnimation(fillAnimation);
							}
						});

						var ripple = new Circle({
							x: e.pageX,
							y: e.pageY,
							r: 0,
							fill: "#3cf0ff",
							stroke: {
								width: 3,
								color: "#3cf0ff"
							},
							opacity: 1
						});
						var rippleAnimation = anime({
							targets: ripple,
							r: rippleSize,
							opacity: 0,
							easing: "easeOutExpo",
							duration: 900,
							complete: removeAnimation
						});

						var particles = [];
						for (var i = 0; i < 32; i++) {
							var particle = new Circle({
								x: e.pageX,
								y: e.pageY,
								fill: currentColor,
								r: anime.random(24, 48)
							});
							particles.push(particle);
						}
						var particlesAnimation = anime({
							targets: particles,
							x: function x(particle) {
								return particle.x + anime.random(rippleSize, -rippleSize);
							},
							y: function y(particle) {
								return particle.y + anime.random(rippleSize * 1.15, -rippleSize * 1.15);
							},
							r: 0,
							easing: "easeOutExpo",
							duration: anime.random(1000, 1300),
							complete: removeAnimation
						});
						animations.push(fillAnimation, rippleAnimation, particlesAnimation);
					}

					function extend(a, b) {
						for (var key in b) {
							if (b.hasOwnProperty(key)) {
								a[key] = b[key];
							}
						}
						return a;
					}

					var Circle = function Circle(opts) {
						extend(this, opts);
					};

					Circle.prototype.draw = function () {
						ctx.globalAlpha = this.opacity || 1;
						ctx.beginPath();
						ctx.arc(this.x, this.y, this.r, 0, 2 * Math.PI, false);
						if (this.stroke) {
							ctx.strokeStyle = this.stroke.color;
							ctx.lineWidth = this.stroke.width;
							ctx.stroke();
						}
						if (this.fill) {
							ctx.fillStyle = this.fill;
							ctx.fill();
						}
						ctx.closePath();
						ctx.globalAlpha = 1;
					};

					var animate = anime({
						duration: 3825,
						update: function update(animation) {
							ctx.fillStyle = bgColor;
							ctx.fillRect(0, 0, cW, cH);
							animations.forEach(function (anim) {
								anim.animatables.forEach(function (animatable) {
									animatable.target.draw();
								});
							});

							// console.log(animation);
							// if(animation.progress > 50)
							// 	landingService.animatedExplosion();
						}
					});

					var resizeCanvas = function resizeCanvas() {
						cW = window.innerWidth;
						cH = window.innerHeight;
						c.width = cW * devicePixelRatio;
						c.height = cH * devicePixelRatio;
						ctx.scale(devicePixelRatio, devicePixelRatio);
					};

					(function init() {
						resizeCanvas();
						if (window.CP) {
							// CodePen's loop detection was causin' problems
							// and I have no idea why, so...
							window.CP.PenTimer.MAX_TIME_IN_LOOP_WO_EXIT = 6000;
						}
						window.addEventListener("resize", resizeCanvas);
						addClickListeners();
						if (!!window.location.pathname.match(/fullcpgrid/)) {
							startFauxClicking();
						}
						handleInactiveUser();
					})();

					function handleInactiveUser() {
						var inactive = setTimeout(function () {
							fauxClick(cW / 2, cH / 2);
						}, 0);

						function clearInactiveTimeout() {
							clearTimeout(inactive);
							document.removeEventListener("mousedown", clearInactiveTimeout);
							document.removeEventListener("touchstart", clearInactiveTimeout);
						}

						document.addEventListener("mousedown", clearInactiveTimeout);
						document.addEventListener("touchstart", clearInactiveTimeout);
					}

					function startFauxClicking() {
						setTimeout(function () {
							fauxClick(anime.random(cW * .2, cW * .8), anime.random(cH * .2, cH * .8));
							startFauxClicking();
						}, anime.random(200, 900));
					}

					function fauxClick(x, y) {
						var fauxClick = new Event("mousedown");
						fauxClick.pageX = x;
						fauxClick.pageY = y;
						document.dispatchEvent(fauxClick);
					}
				}, 0); //timeout
			});
		}
	};
}]);

portfolio.directive("bubbleGradient", [/*"ColorService",*/
function () /*ColorService*/{
	return {
		restrict: 'AE',
		// templateUrl: 'js/directives/bubble-gradient/bubble-gradient.html',
		link: function link(scope, element, attr, ctrl) {

			var bg = $('<canvas id="bubble-gradient" width="' + element.width() + '" height="' + element.height() + '"></canvas>').css({
				'z-index': 0,
				'position': 'absolute'
			});
			element.append(bg);

			console.log(scope, element, this);
			var mainCanvas = document.querySelector("#bubble-gradient");
			var mainContext = mainCanvas.getContext("2d");

			var canvasWidth = mainCanvas.width;
			var canvasHeight = mainCanvas.height;

			// empty the canvas
			mainContext.clearRect(0, 0, canvasWidth, canvasHeight);

			// color in the background of the canvas
			mainContext.fillStyle = "#EEEEEE";
			mainContext.fillRect(0, 0, canvasWidth, canvasHeight);

			var Circle = function Circle(x, y, full) {
				//x,y distance from top right; full is radius when fully grown
				this.x = x;
				this.y = y;
				this.radius = 0;
				this.angle = 0;
				this.full = full;
			};
			Circle.prototype.grow = function () {
				mainContext.beginPath();

				this.radius = this.full * Math.abs(Math.sin(this.angle));
				mainContext.arc(canvasWidth - this.x, this.y, this.radius, 0, Math.PI * 2, false);
				mainContext.closePath();

				// color in the circle
				mainContext.fillStyle = "#006699";
				mainContext.fill();

				this.angle += .01;

				// circle has not reached full radius length
				if (this.radius < this.full) return false;else return true;
			};

			var x, y, xmax, ymin, interval, xincrement, yincrement;
			x = y = xmax = ymin = 0;
			interval = 10;
			xincrement = canvasHeight / 5;
			yincrement = canvasHeight / 5;
			var bubble = setInterval(function () {
				var circle = new Circle(x, y, canvasWidth / 5);
				var animateCircle = setInterval(function () {
					if (circle.grow()) clearInterval(animateCircle);
				}, 1);

				if (x >= canvasWidth && y >= canvasHeight) {
					//filled up canvas
					console.log('stopping');
					clearInterval(bubble);
				} else if (x <= 0 || y >= canvasHeight) {
					if (xmax < canvasWidth) {
						xincrement -= 5;
						xmax += xincrement;
					} else {
						ymin += yincrement;
					}
					y = ymin;
					x = xmax;
				} else {
					x -= xincrement;
					y += yincrement;
				}

				// interval+=10;
				// if(interval>2) interval--;
			}, interval);
		}
	};
}]);

portfolio.directive('landingContent', ['$timeout', 'landingService', function ($timeout, landingService) {
	return {
		restrict: 'AE',
		templateUrl: 'js/directives/landing-content/landing-content.html',
		scope: false, //use scope from PortfolioController
		link: function link(scope, element, attr, ctrl) {

			var greeting = element[0].querySelector('h1');
			var intro = element[0].querySelector('p');

			// finished animating squares, so animate landing card
			landingService.canAnimateCard().then(function () {
				greeting.style.display = 'block';

				$timeout(function () {
					scope.showLandingContent = true;
					angular.element(document.getElementById('action-button')).toggleClass('show-action-button');
				});

				var greetingAnimationHalwayFinished = false;
				anime({
					targets: greeting,
					delay: 222,
					translateY: {
						value: ['4.2em', '0em'],
						duration: 1888,
						direction: 'normal',
						delay: 2000
					},
					fontSize: {
						value: ['2em', '1.2em'],
						duration: 1888,
						direction: 'normal',
						delay: 2000
					},
					// opacity: {
					// 	value: [0, 1],
					// 	duration: 888,
					// 	easing: 'linear'
					// },
					update: function update(animation) {
						// animate intro paragraph
						if (greetingAnimationHalwayFinished == false && animation.progress > 50) {
							greetingAnimationHalwayFinished = true;
							intro.style.display = 'block';
							anime({
								targets: intro,
								delay: 222,
								opacity: {
									value: [0, 1],
									duration: 888
								},
								complete: function complete() {
									landingService.animatedCard();
								}
							});
						}
					}
				});

				landingService.canAnimateControls().then(function () {
					$timeout(function () {
						document.getElementById('side-controls').style.opacity = 1;
						document.querySelector('#side-controls a:last-child').style.transform = "scale(1)";
						document.querySelector('#side-controls a:last-child').style.animation = "pulse .8s infinite alternate";
					}, 888);
				});
			});
		}
	};
}]);
// portfolio.directive('card', ['$drag', 'projectsService',
// 	function($drag, projectsService) {
// 		return {
// 			restrict: 'C',
// 			transclude: true,
// 			template: '<div class="project"><div ng-transclude></div></div>',

// 			// these added to test out ng-repeat with ng-transclude			
// 			// transclude: 'element',
// 			// replace: true,
// 			// scope: true,
// 			// template: [
// 			// 	''
// 			// ],

// 			controller: 'PortfolioController',
// 			// require: '^PortfolioController',
// 			link: function(scope, elem, attrs, PortfolioController) {

// 				document.querySelector('#link-tally p').innerHTML += '1';

// 				// console.log(scope);
// 				var id = projectsService.addCard();
// 				console.log(elem[0], id);
// 				var zIndex = function() {
// 					var res = 0;
// 					if (id === projectsService.activeCard()) {
// 						res = 2000;
// 					} else if (projectsService.activeCard() < id) {
// 						res = 2000 - (id - projectsService.activeCard());
// 					} else {
// 						res = 2000 - (projectsService.cardCount() - 1 - projectsService.activeCard() + id);
// 					}
// 					return res;
// 				};

// 				scope.$watch(() => {
// 					return projectsService.activeCard();
// 				}, () => {
// 					// console.log('niqua');
// 					// console.log(projectsService.activeCard());
// 					elem[0].style.zIndex = zIndex();
// 				});

// 				$drag.bind(elem, {
// 					transform: function(element, transform, touch) {
// 						var t = $drag.TRANSLATE_BOTH(element, transform, touch),
// 							Dx = touch.distanceX,
// 							t0 = touch.startTransform,
// 							sign = Dx < 0 ? -1 : 1,
// 							angle = sign * Math.min((Math.abs(Dx) / 700) * 30, 30);

// 						t.rotateZ = angle + (Math.round(t0.rotateZ));
// 						return t;
// 					},
// 					start: (drag, event) => {
// 						event.stopPropagation();
// 						PortfolioController.scrollableToggle(false);
// 					},
// 					move: function(drag, event) {
// 						event.stopPropagation();
// 						if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
// 							elem.addClass('dismiss');
// 						} else {
// 							elem.removeClass('dismiss');
// 						}
// 					},
// 					cancel: function() {
// 						elem.removeClass('dismiss');
// 					},
// 					end: function(drag) {
// 						PortfolioController.scrollableToggle(true);
// 						elem.removeClass('dismiss');
// 						if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
// 							console.log('is greater');
// 							scope.$apply(function() {
// 								projectsService.next();
// 							});
// 						}
// 						drag.reset();
// 					}
// 				});

// 			}
// 		};
// 	}
// ]);

// // portfolio.directive('cards', function() {
// //   return {
// //     restrict: 'C',
// //     scope: {},
// //     controller: function() {
// //       this.itemCount = 0;
// //       this.activeItem = null;

// //       this.addItem = function() {
// //         var newId = this.itemCount++;
// //         this.activeItem = this.itemCount === 1 ? newId : this.activeItem;
// //         return newId;
// //       };

// //       this.next = function() {
// //         this.activeItem = this.activeItem || 0;
// //         this.activeItem = this.activeItem === this.itemCount - 1 ? 0 : this.activeItem + 1;
// //       };

// //       this.prev = function() {
// //         this.activeItem = this.activeItem || 0;
// //         this.activeItem = this.activeItem === 0 ? this.itemCount - 1 : this.activeItem - 1;
// //       };
// //     }
// //   };
// // });

// // portfolio.directive('card', function($drag) {
// //   return {
// //     restrict: 'C',
// //     require: '^cards',
// //     scope: {},
// //     transclude: true,
// //     template: '<div class="item"><div ng-transclude></div></div>',
// //     link: function(scope, elem, attrs, carousel) {
// //       scope.carousel = carousel;
// //       var id = carousel.addItem();

// //       var zIndex = function() {
// //         var res = 0;
// //         if (id === carousel.activeItem) {
// //           res = 2000;
// //         } else if (carousel.activeItem < id) {
// //           res = 2000 - (id - carousel.activeItem);
// //         } else {
// //           res = 2000 - (carousel.itemCount - 1 - carousel.activeItem + id);
// //         }
// //         return res;
// //       };

// //       scope.$watch(function() {
// //         return carousel.activeItem;
// //       }, function() {
// //         elem[0].style.zIndex = zIndex();
// //       });

// //       $drag.bind(elem, {
// //         //
// //         // This is an example of custom transform function
// //         //
// //         transform: function(element, transform, touch) {
// //           //
// //           // use translate both as basis for the new transform:
// //           //
// //           var t = $drag.TRANSLATE_BOTH(element, transform, touch);

// //           //
// //           // Add rotation:
// //           //
// //           var Dx    = touch.distanceX;
// //           var t0    = touch.startTransform;
// //           var sign  = Dx < 0 ? -1 : 1;
// //           var angle = sign * Math.min((Math.abs(Dx) / 700) * 30 , 30);

// //           t.rotateZ = angle + (Math.round(t0.rotateZ));

// //           return t;
// //         },
// //         move: function(drag) {
// //           if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
// //             elem.addClass('dismiss');
// //           } else {
// //             elem.removeClass('dismiss');
// //           }
// //         },
// //         cancel: function() {
// //           elem.removeClass('dismiss');
// //         },
// //         end: function(drag) {
// //           elem.removeClass('dismiss');
// //           if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
// //             scope.$apply(function() {
// //               carousel.next();
// //             });
// //           }
// //           drag.reset();
// //         }
// //       });
// //     }
// //   };
// // });
// portfolio.directive('hmDir', ['$timeout', '$http', 'projectsService',
// 	function($timeout, $http, projectsService) {
// 		return {
// 			restrict: 'AE',
// 			controller: 'PortfolioController',
// 			scope: true,
// 			// scope: {
// 			// 	'spark': '=project',
// 			// 	'neroli': '=project'
// 			// },
// 			link: (scope, element, attrs, controller) => {
// 				// console.log(attrs);

// 			},
// 			compile: function(tElem, tAttrs) {
// 				return {
// 					pre: function(scope, iElem, iAttrs) {
// 						console.log(scope);
// 						// scope.$watch('project', function(value) {
// 						// 	// setInterval(()=>{console.log(value);},1000);

// 						// 	projectsService.canAddMethods().then(() => {

// 						// 		var computedPosition, top, left, card, cardHeight;

// 						// 		// console.log(iElem[0].getElementsByClassName('card')[0]);
// 						// 		card = iElem[0].getElementsByClassName('card')[0];
// 						// 		// console.log(card);
// 						// 		cardHeight = card.offsetHeight;
// 						// 		// console.log(card.getBoundingClientRect());
// 						// 		computedPosition = card.getBoundingClientRect();
// 						// 		$timeout(() => {
// 						// 			// computedPosition = card.getBoundingClientRect(),
// 						// 			top = computedPosition.top - cardHeight,
// 						// 				left = computedPosition.left;
// 						// 		});

// 						// 		// console.log(scope.projects);
// 						// 		// console.log(iAttrs.project);
// 						// 		// console.log(scope.projects[iAttrs.project]);
// 						// 		// console.log(scope.projects);
// 						// 		value.hammer = {
// 						// 			onPan: event => {
// 						// 				console.log(event);
// 						// 				if (event.target === card) {
// 						// 					// scope[key].dragging = true;
// 						// 					iElem.children().css({
// 						// 						'left': left + event.deltaX + 'px',
// 						// 						'top': top - cardHeight + event.deltaY + 'px'
// 						// 					});
// 						// 				}
// 						// 			},
// 						// 			endPan: event => {
// 						// 				computedPosition = card.getBoundingClientRect(),
// 						// 					top = computedPosition.top - cardHeight,
// 						// 					left = computedPosition.left;
// 						// 				// scope[key].dragging = false;
// 						// 			},
// 						// 			swipeRight: event => {
// 						// 				// console.log('swiped',event);
// 						// 			}
// 						// 		};
// 						// 		// console.log(scope.projects[iAttrs.project]);

// 						// 		 // hm-panmove="{{project.hammer.onPan}}" hm-panend="{{project_name}}.hammer.endPan" hm-swiperight="project.hammer.swipeRight"

// 						// 		// console.log(iElem);
// 						// 		console.log(scope);
// 						// 		// iElem.val('hm-panmove',)

// 						// 	});

// 						// });

// 						projectsService.canAddMethods().then(() => {
// 							$timeout(() => {
// 								// var computedPosition, top, left, card, cardHeight;

// 								// // console.log(iElem[0].getElementsByClassName('card')[0]);
// 								// card = iElem[0].getElementsByClassName('card')[0];
// 								// // console.log(card);
// 								// cardHeight = card.offsetHeight;
// 								// // console.log(card.getBoundingClientRect());
// 								// computedPosition = card.getBoundingClientRect();
// 								// $timeout(() => {
// 								// 	// computedPosition = card.getBoundingClientRect(),
// 								// 	top = computedPosition.top - cardHeight,
// 								// 		left = computedPosition.left;
// 								// });

// 								// // console.log(scope.projects);
// 								// // console.log(iAttrs.project);
// 								// // console.log(scope.projects[iAttrs.project]);
// 								// scope.projects[iAttrs.project].hammer = {
// 								// 	onPan: event => {
// 								// 		console.log(event);
// 								// 		if (event.target === card) {
// 								// 			// scope[key].dragging = true;
// 								// 			iElem.children().css({
// 								// 				'left': left + event.deltaX + 'px',
// 								// 				'top': top - cardHeight + event.deltaY + 'px'
// 								// 			});
// 								// 		}
// 								// 	},
// 								// 	endPan: event => {
// 								// 		computedPosition = card.getBoundingClientRect(),
// 								// 			top = computedPosition.top - cardHeight,
// 								// 			left = computedPosition.left;
// 								// 		// scope[key].dragging = false;
// 								// 	},
// 								// 	swipeRight: event => {
// 								// 		// console.log('swiped',event);
// 								// 	}
// 								// };
// 								// console.log(scope.projects[iAttrs.project]);
// 							});
// 						});

// 					}

// 					/*,
// 					post: function(scope, iElem, iAttrs) {
// 						// each card needs its own Hammer functions
// 						Object.keys(scope).forEach(function(key, index) {
// 							if (key == iAttrs.project) {
// 								var computedPosition, top, left, card, cardContentHeight;
// 								card = iElem[0].getElementsByClassName('card')[0],
// 								cardContentHeight = card.querySelector('.card-content').offsetHeight;
// 								// console.log(card.getBoundingClientRect());
// 								computedPosition = card.getBoundingClientRect();
// 								$timeout(() => {
// 									// computedPosition = card.getBoundingClientRect(),
// 									top = computedPosition.top - cardContentHeight,
// 									left = computedPosition.left;
// 									// console.log(computedPosition);
// 								});
// 								scope[key] = {
// 									dragging: false,
// 									onPan: event => {
// 										if (event.target === card) {
// 											// scope[key].dragging = true;
// 											iElem.children().css({
// 												'left': left + event.deltaX + 'px',
// 												'top': top - cardContentHeight + event.deltaY + 'px'
// 											});
// 										}
// 									},
// 									endPan: event => {
// 										computedPosition = card.getBoundingClientRect(),
// 										top = computedPosition.top - cardContentHeight,
// 										left = computedPosition.left;
// 										// scope[key].dragging = false;
// 									},
// 									swipeRight: event => {
// 										// console.log('swiped',event);
// 									}
// 								};

// 							}
// 						});
// 					}
// 					*/
// 				}
// 			}

// 		}
// 	}
// ]);

portfolio.directive('card', ['$drag', '$touch', 'projectsService', function ($drag, $touch, projectsService) {
	return {
		restrict: 'C',
		transclude: true,
		template: '<div class="project"><div ng-transclude></div></div>',
		controller: 'PortfolioController',
		// require: '^PortfolioController',
		link: function link(scope, elem, attrs, PortfolioController) {

			var id, index, zIndex, zIndexDelta;
			id = index = projectsService.addCard();
			zIndexDelta = 0;
			zIndex = elem[0].style.zIndex;

			scope.$watch(function () {
				return projectsService.activeCard();
			}, function () {
				//update zindex
				zIndexDelta = 0;
				if (id === projectsService.activeCard()) zIndexDelta = 0;else if (projectsService.activeCard() < id) zIndexDelta = id - projectsService.activeCard();else zIndexDelta = projectsService.cardCount() - 1 - projectsService.activeCard() + id;
				elem[0].style.zIndex = 2000 - zIndexDelta;

				//update width and position from top
				if (index < 0) index = projectsService.cardCount() - 1;
				index--;
				elem[0].style.width = 100 - (index + 1) + '%';
				elem[0].style.top = projectsService.cardSpreadInterval() * (index + 1) + 'px';
			});

			$drag.bind(elem, {
				transform: function transform(element, _transform, touch) {
					var t = $drag.TRANSLATE_BOTH(element, _transform, touch),
					    Dx = touch.distanceX,
					    t0 = touch.startTransform,
					    sign = Dx < 0 ? -1 : 1,
					    angle = sign * Math.min(Math.abs(Dx) / 700 * 30, 30);

					t.rotateZ = angle + Math.round(t0.rotateZ);
					return t;
				},
				start: function start(drag, event) {
					event.stopPropagation();
					PortfolioController.scrollableToggle(false);
				},
				move: function move(drag, event) {
					event.stopPropagation();
					elem[0].style.opacity = 1 - Math.abs(drag.distanceX) / drag.rect.width;
					if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
						elem.addClass('dismiss');
					} else {
						elem.removeClass('dismiss');
					}
				},
				cancel: function cancel() {
					elem.removeClass('dismiss');
				},
				end: function end(drag) {
					elem[0].style.opacity = 1;
					PortfolioController.scrollableToggle(true);
					elem.removeClass('dismiss');
					if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
						scope.$apply(function () {
							projectsService.next();
						});
					}
					drag.reset();
				}
			});

			$touch.bind(elem, {
				end: function end(touchInfo, event) {
					if (Math.abs(touchInfo.total) < elem[0].clientWidth / 8) {
						var flipCard = elem[0].querySelector('.flip-card');
						flipCard.classList.toggle('flipped');
					}
				}
			});
		}
	};
}]);