'use strict';

var portfolio = angular.module('portfolio', ['ngAnimate', 'ngSanitize', 'mobile-angular-ui', 'mobile-angular-ui.gestures.drag', 'mobile-angular-ui.gestures.touch', 'ngAnimate', 'ngSanitize', 'duScroll'])
// these values are configuration settings for angular-scroll
// .value('duScrollEasing', x => {
// 	return 1-x;
// })
.value('duScrollOffset', 88);
portfolio.factory('landingService', ['$q', function ($q) {

	// animated the B
	var _animatedB = $q.defer();
	// animatedB.promise.then(console.log('resolved animatedB'));

	// created the squares
	var _createdSquares = $q.defer();

	// finished animating B and creating squares, so animate the squares
	var requiredForAnimatingSquares = [_animatedB.promise, _createdSquares.promise];

	// animated squares
	var _animatedSquares = $q.defer();

	// animated the card
	// this.animatedCard = $q.defer();
	// this.animatedCard.promise

	// var qlandingAnimated = $q.defer();
	// var plandingAnimated = qlandingAnimated.promise;

	return {
		'animatedB': function animatedB() {
			return _animatedB.resolve();
		},
		'createdSquares': function createdSquares() {
			return _createdSquares.resolve();
		},
		'canAnimateSquares': function canAnimateSquares() {
			return $q.all(requiredForAnimatingSquares);
		},
		'animatedSquares': function animatedSquares() {
			return _animatedSquares.resolve();
		},
		'canAnimateCard': function canAnimateCard() {
			return _animatedSquares.promise;
		}
	};
}]);
portfolio.factory('projectsService', ['$q', '$http', '$rootScope', 'landingService', function ($q, $http, $rootScope, landingService) {

	landingService.canAnimateCard().then(function () {
		// using rootScope and doing $http over here because doesnt work in controller
		$http.get('resources/json/projects.json').then(function (response) {
			$rootScope.projects = response.data;
		});
	});

	var _cardCount = 0;
	var _activeCard = null;

	return {
		cardCount: function cardCount() {
			return _cardCount;
		},
		activeCard: function activeCard() {
			return _activeCard;
		},
		addCard: function addCard() {
			var newId = _cardCount++;
			_activeCard = _cardCount === 1 ? newId : _activeCard;
			return newId;
		},
		next: function next() {
			_activeCard = _activeCard || 0;
			_activeCard = _activeCard === _cardCount - 1 ? 0 : _activeCard + 1;
		},
		prev: function prev() {
			_activeCard = _activeCard || 0;
			_activeCard = _activeCard === 0 ? _cardCount - 1 : _activeCard - 1;
		},
		cardSpreadInterval: function cardSpreadInterval() {
			//cards take up 95% height, so space is 5%
			var cardSpreadInterval = document.querySelector('.cards-inner').clientHeight * .05 / (_cardCount - 1);
			if (_cardCount > 0) return cardSpreadInterval;
		}

	};
}]);
portfolio.controller('3DBoxController', [function () {
	var vm = this;

	// vm.side = 'show-front';

	var vw = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
	var vh = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

	var boxContainerStyle = document.getElementById('box-container').style;
	boxContainerStyle.width = vw + 'px';
	boxContainerStyle.height = vh + 'px';

	var translateZ = vw / 2 + 'px';
	var box = document.getElementById('box');
	box.style.transform = 'translateZ(-' + translateZ + ') rotateY(0deg)';

	var sides = ['front', 'right', 'back', 'left'];
	for (var i = sides.length - 1; i >= 0; i--) {
		var rotateY;
		switch (sides[i]) {
			case 'front':
				rotateY = '0deg';
				break;
			case 'right':
				rotateY = '90deg';
				break;
			case 'back':
				rotateY = '180deg';
				break;
			case 'left':
				rotateY = '-90deg';
				break;
		}
		var side = document.querySelector('#box .' + sides[i]);
		side.style.transform = 'rotateY(' + rotateY + ') translateZ(' + translateZ + ')';
		side.style.width = vw + 'px';
		side.style.height = vh + 'px';
	}

	vm.showSide = function (side) {
		var rotateY;
		switch (side) {
			case 'front':
				rotateY = '0deg';
				break;
			case 'right':
				rotateY = '-90deg';
				break;
			case 'back':
				rotateY = '-180deg';
				break;
			case 'left':
				rotateY = '-270deg';
				break;
		}
		box.style.transform = 'translateZ(-' + translateZ + ') rotateY(' + rotateY + ')';
	};
}]);
// portfolio.controller('LandingController', function($scope, landingService, ){

// });
// portfolio.controller('PortfolioController', [
// 	'$scope',
// 	'$http',
// 	'$window',
// 	'projectsService',
// 	'$location',
// 	'$anchorScroll',
// 	'$document', /*"uiGmapGoogleMapApi", "ColorService", 'ScrollService',*/
// 	'$rootScope',
// 	function($scope, $http, $window, projectsService, $location, $anchorScroll, $document, $rootScope /*, uiGmapGoogleMapApi, ColorService, ScrollService*/) {
// 		var self = this;

// 		$scope.projects = [];
// 		// ProjectsService.loadProjectsInto($scope.projects);
// 		$scope.renderCards= false;
// 		// $http.get('resources/json/projects.json')
// 		// 	.then(response => {
// 		// 		// console.log(response.data);
// 		// 		console.log('loading');
// 		// 		$scope.projects = response.data;
// 		// 		// projectsService.loadedProjects();
// 		// 		// $scope.renderCards = true;
// 		// 	});

// 		// projectsService.loadProjects()
// 		// projectsService.canAddToScope().then(() => {
// 		// 	$scope.projects = projectsService.projects();
// 		// 	console.log($scope.projects);
// 		// });

// 		// projectsService.projects().then(() => {
// 		// 	// $rootScope.projects =
// 		// 	console.log(this);
// 		// });
// 		// console.log($rootScope.projects);
// 		$rootScope.$watch('projects', () => {
// 			console.log('updated');
// 			console.log($rootScope.projects);
// 		});

// 		var birthdate = moment("1993-08-24 00:00").startOf('minute');
// 		this.ageyears = moment().diff(birthdate, 'years');
//         this.agemonths = moment().subtract(this.ageyears, 'years').diff(birthdate, 'months');
//         this.ageseconds = moment().subtract(this.ageyears, 'years').subtract(this.agemonths, 'months').diff(birthdate, 'seconds');
//         setInterval(() => $scope.$apply(() =>
//             this.ageseconds++ //make me older by a second every second
//         ), 1000);

// 		$scope.goToSecond = () => {
// 			// $location.hash('second');
// 			// $anchorScroll();
// 			$document.scrollToElementAnimated(angular.element(document.getElementById('second')));
// 		}

// 		$scope.showLandingContent = false;
// 		$scope.scrollable = 'scrollable';
// 		this.scrollableToggle = state => {
// 			$scope.scrollable = state ? 'scrollable' : 'unscrollable';
// 			// console.log($scope.scrollable);
// 		}

// 		angular.element($window).bind( //when user reaches bottom of page
// 			"scroll",
// 	 		function() {
// 				var windowHeight = "innerHeight" in window ? window.innerHeight : document.documentElement.offsetHeight;
// 				var body = document.body, html = document.documentElement;
// 				var docHeight = Math.max(body.scrollHeight,
// 						body.offsetHeight, html.clientHeight,
// 						html.scrollHeight, html.offsetHeight);
// 				var windowBottom = windowHeight + window.pageYOffset;
// 				if (windowBottom >= docHeight) {
// 					// alert('bottom reached');
// 					console.log('bottom reached');
// 					// self.scrollableToggle(false);
// 				}
// 			}
// 		);

// 		// var gottem = false;
// 		// $http.get('resources/json/items.json')
// 		// 	.then(response => {
// 		// 		// $scope.projects
// 		// 		// if(gottem === false){
// 		// 		// 	console.log(response.data);
// 		// 		// 	gottem = true;	
// 		// 		// }
// 		// 		setTimeout(() => {
// 		// 			console.log(response.data);
// 		// 			console.log('finished');
// 		// 		}, 5555);

// 		// 	});
// 		// $http({
// 		// 	method: 'GET',
// 		// 	url: 'resources/json/items.json'
// 		// }).then(function successCallback(response) {
// 		// 	// this callback will be called asynchronously
// 		// 	// when the response is available
// 		// 	console.log('success',response.data);
// 		// }, function errorCallback(response) {
// 		// 	// called asynchronously if an error occurs
// 		// 	// or server returns response with an error status.
// 		// 	console.log('error',response.data);
// 		// });
// 		// $http({
// 		// 	method: 'GET',
// 		// 	url: 'resources/json/items.json'
// 		// }).success((data,status) => {
// 		// 	console.log('success',data);
// 		// }).error((data,status) => {
// 		// 	console.log('error',data);
// 		// });

// 	}
// ]);
portfolio.controller('PortfolioController', ['$scope', '$http', '$window', '$timeout', 'projectsService', 'landingService', '$location', '$anchorScroll', '$document', /*"uiGmapGoogleMapApi", "ColorService", 'ScrollService',*/
'$rootScope', function ($scope, $http, $window, $timeout, projectsService, landingService, $location, $anchorScroll, $document, $rootScope /*, uiGmapGoogleMapApi, ColorService, ScrollService*/) {
	var _this = this;

	var self = this;

	// $scope.side = 'show-front';

	var birthdate = moment("1993-08-24 00:00").startOf('minute');
	this.ageyears = moment().diff(birthdate, 'years');
	this.agemonths = moment().subtract(this.ageyears, 'years').diff(birthdate, 'months');
	this.ageseconds = moment().subtract(this.ageyears, 'years').subtract(this.agemonths, 'months').diff(birthdate, 'seconds');
	setInterval(function () {
		return $scope.$apply(function () {
			return _this.ageseconds++;
		} //make me older by a second every second
		);
	}, 1000);

	$scope.goToSecond = function () {
		// $location.hash('second');
		// $anchorScroll();
		$document.scrollToElementAnimated(angular.element(document.getElementById('second')));
	};

	$scope.showLandingContent = false;
	$scope.scrollable = 'scrollable';
	this.scrollableToggle = function (state) {
		$scope.scrollable = state ? 'scrollable' : 'unscrollable';
	};

	this.showLandingContent = function () {};

	$scope.enableCards = 'cardsDisabled';
	angular.element($window).bind( //when user reaches bottom of page
	"scroll", function () {
		var windowHeight = "innerHeight" in window ? window.innerHeight : document.documentElement.offsetHeight;
		var body = document.body,
		    html = document.documentElement;
		var docHeight = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
		var windowBottom = windowHeight + window.pageYOffset;
		if (windowBottom >= docHeight) {
			console.log('bottom reached');
			$scope.enableCards = 'cardsEnabled';
		}
	});
}]);
portfolio.directive('actionButton', function () {
	return {
		link: function link(scope, element, attrs) {
			element.bind('click', function () {
				element.toggleClass('open');
			});
		}
	};
});
portfolio.directive('animejsBanner', ['$q', 'landingService', /*"ColorService",*/
function ($q, landingService /*,ColorService*/) {
	return {
		restrict: 'AE',
		templateUrl: 'js/directives/animejs-banner/animejs-banner.html',
		controller: 'PortfolioController',
		link: function link(scope, element, attr, ctrl) {

			// animate the B
			var loadingSquares = element[0].querySelector('#loading-squares');
			anime({
				targets: '#Bsvg path',
				strokeDashoffset: {
					easing: 'easeInOutExpo',
					duration: 500,
					value: function value(el) {
						var pathLength = el.getTotalLength();
						el.setAttribute('stroke-dasharray', pathLength);
						return [-pathLength, 0];
					}
				},
				stroke: {
					value: function value(el, i) {
						return 'rgb(' + i * 2 + ',' + i * 8 + ',' + i * 12 + ')';
					},
					easing: 'linear',
					duration: 222
				},
				strokeWidth: {
					value: 8,
					easing: 'linear',
					delay: function delay(el, i) {
						return 600 + i * 8;
					},
					duration: 222
				},
				delay: function delay(el, i) {
					return i * 30;
				},
				duration: 1200,
				easing: 'easeOutExpo',
				loop: false,
				direction: 'alternate',
				update: function update(animation) {
					//start animating squares once B is loaded
					if (animation.reversed == true) landingService.animatedB();
				},
				complete: function complete() {
					// console.log('finished loadingscreen');
				}
			});

			// create the elements for the squares
			var squares = element[0].querySelector('#squares');
			var x, y, xmax, ymin, xincrement, yincrement;
			x = y = xmax = ymin = 0;
			var size = Math.min(Math.ceil(element.height() / 3.8), 122);
			xincrement = yincrement = size; //width and height of each square
			do {
				squares.innerHTML += '\n\t\t\t\t\t\t\t\t\t\t\t\t<article style="width:' + xincrement + 'px;height:' + yincrement + 'px;top:' + y + 'px;right:' + x + 'px">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t\t\t\t\t\t</article>\n\t\t\t\t\t\t\t\t\t\t\t';

				if (x < xincrement || y > element.height() - yincrement) {
					if (xmax < element.width()) {
						xmax += xincrement;
					} else {
						ymin += yincrement;
					}
					y = ymin;
					x = xmax;
				} else {
					x -= xincrement;
					y += yincrement;
				}
			} while (x < element.width() || y < element.height());
			$('#squares').css('display', 'block');
			// console.log('finished building squares');
			landingService.createdSquares();

			// B is animated AND squares are created
			landingService.canAnimateSquares().then(function () {
				anime({
					targets: '#squares div',
					rotate: {
						value: 180,
						duration: 888,
						easing: 'linear'
					},
					scale: {
						value: [0, 1],
						// delay: 150,
						duration: 888,
						easing: 'easeInOutExpo'
					},
					loop: false,
					direction: 'normal',
					borderRadius: {
						value: 0,
						duration: 1222,
						easing: 'linear'
					},
					backgroundColor: '#18212D',
					delay: function delay(el, index, total) {
						var duration = 888; //duration of squares animation
						return index * (duration / total);
					},
					update: function update(animation) {
						if (animation.progress > 75) landingService.animatedSquares();
					},
					complete: function complete() {
						squares.className += 'bg-dark';
						element.find('article').hide();
					}
				});
			});
		}
	};
}]);

portfolio.directive("bubbleGradient", [/*"ColorService",*/
function () /*ColorService*/{
	return {
		restrict: 'AE',
		// templateUrl: 'js/directives/bubble-gradient/bubble-gradient.html',
		link: function link(scope, element, attr, ctrl) {

			var bg = $('<canvas id="bubble-gradient" width="' + element.width() + '" height="' + element.height() + '"></canvas>').css({
				'z-index': 0,
				'position': 'absolute'
			});
			element.append(bg);

			console.log(scope, element, this);
			var mainCanvas = document.querySelector("#bubble-gradient");
			var mainContext = mainCanvas.getContext("2d");

			var canvasWidth = mainCanvas.width;
			var canvasHeight = mainCanvas.height;

			// empty the canvas
			mainContext.clearRect(0, 0, canvasWidth, canvasHeight);

			// color in the background of the canvas
			mainContext.fillStyle = "#EEEEEE";
			mainContext.fillRect(0, 0, canvasWidth, canvasHeight);

			var Circle = function Circle(x, y, full) {
				//x,y distance from top right; full is radius when fully grown
				this.x = x;
				this.y = y;
				this.radius = 0;
				this.angle = 0;
				this.full = full;
			};
			Circle.prototype.grow = function () {
				mainContext.beginPath();

				this.radius = this.full * Math.abs(Math.sin(this.angle));
				mainContext.arc(canvasWidth - this.x, this.y, this.radius, 0, Math.PI * 2, false);
				mainContext.closePath();

				// color in the circle
				mainContext.fillStyle = "#006699";
				mainContext.fill();

				this.angle += .01;

				// circle has not reached full radius length
				if (this.radius < this.full) return false;else return true;
			};

			var x, y, xmax, ymin, interval, xincrement, yincrement;
			x = y = xmax = ymin = 0;
			interval = 10;
			xincrement = canvasHeight / 5;
			yincrement = canvasHeight / 5;
			var bubble = setInterval(function () {
				var circle = new Circle(x, y, canvasWidth / 5);
				var animateCircle = setInterval(function () {
					if (circle.grow()) clearInterval(animateCircle);
				}, 1);

				if (x >= canvasWidth && y >= canvasHeight) {
					//filled up canvas
					console.log('stopping');
					clearInterval(bubble);
				} else if (x <= 0 || y >= canvasHeight) {
					if (xmax < canvasWidth) {
						xincrement -= 5;
						xmax += xincrement;
					} else {
						ymin += yincrement;
					}
					y = ymin;
					x = xmax;
				} else {
					x -= xincrement;
					y += yincrement;
				}

				// interval+=10;
				// if(interval>2) interval--;
			}, interval);
		}
	};
}]);

portfolio.directive('landingContent', ['$timeout', 'landingService', /*'ColorService', */
function ($timeout, landingService /*ColorService*/) {
	return {
		restrict: 'AE',
		templateUrl: 'js/directives/landing-content/landing-content.html',
		scope: false, //use scope from PortfolioController
		link: function link(scope, element, attr, ctrl) {

			// finished animating squares, so animate landing card
			landingService.canAnimateCard().then(function () {
				console.log('finished animating squares, so now animate the card');

				$timeout(function () {
					scope.showLandingContent = true;
					angular.element(document.getElementById('action-button')).toggleClass('show-action-button');
				});
			});
		}
	};
}]);
// portfolio.directive('card', ['$drag', 'projectsService',
// 	function($drag, projectsService) {
// 		return {
// 			restrict: 'C',
// 			transclude: true,
// 			template: '<div class="project"><div ng-transclude></div></div>',

// 			// these added to test out ng-repeat with ng-transclude			
// 			// transclude: 'element',
// 			// replace: true,
// 			// scope: true,
// 			// template: [
// 			// 	''
// 			// ],

// 			controller: 'PortfolioController',
// 			// require: '^PortfolioController',
// 			link: function(scope, elem, attrs, PortfolioController) {

// 				document.querySelector('#link-tally p').innerHTML += '1';

// 				// console.log(scope);
// 				var id = projectsService.addCard();
// 				console.log(elem[0], id);
// 				var zIndex = function() {
// 					var res = 0;
// 					if (id === projectsService.activeCard()) {
// 						res = 2000;
// 					} else if (projectsService.activeCard() < id) {
// 						res = 2000 - (id - projectsService.activeCard());
// 					} else {
// 						res = 2000 - (projectsService.cardCount() - 1 - projectsService.activeCard() + id);
// 					}
// 					return res;
// 				};

// 				scope.$watch(() => {
// 					return projectsService.activeCard();
// 				}, () => {
// 					// console.log('niqua');
// 					// console.log(projectsService.activeCard());
// 					elem[0].style.zIndex = zIndex();
// 				});

// 				$drag.bind(elem, {
// 					transform: function(element, transform, touch) {
// 						var t = $drag.TRANSLATE_BOTH(element, transform, touch),
// 							Dx = touch.distanceX,
// 							t0 = touch.startTransform,
// 							sign = Dx < 0 ? -1 : 1,
// 							angle = sign * Math.min((Math.abs(Dx) / 700) * 30, 30);

// 						t.rotateZ = angle + (Math.round(t0.rotateZ));
// 						return t;
// 					},
// 					start: (drag, event) => {
// 						event.stopPropagation();
// 						PortfolioController.scrollableToggle(false);
// 					},
// 					move: function(drag, event) {
// 						event.stopPropagation();
// 						if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
// 							elem.addClass('dismiss');
// 						} else {
// 							elem.removeClass('dismiss');
// 						}
// 					},
// 					cancel: function() {
// 						elem.removeClass('dismiss');
// 					},
// 					end: function(drag) {
// 						PortfolioController.scrollableToggle(true);
// 						elem.removeClass('dismiss');
// 						if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
// 							console.log('is greater');
// 							scope.$apply(function() {
// 								projectsService.next();
// 							});
// 						}
// 						drag.reset();
// 					}
// 				});

// 			}
// 		};
// 	}
// ]);

// // portfolio.directive('cards', function() {
// //   return {
// //     restrict: 'C',
// //     scope: {},
// //     controller: function() {
// //       this.itemCount = 0;
// //       this.activeItem = null;

// //       this.addItem = function() {
// //         var newId = this.itemCount++;
// //         this.activeItem = this.itemCount === 1 ? newId : this.activeItem;
// //         return newId;
// //       };

// //       this.next = function() {
// //         this.activeItem = this.activeItem || 0;
// //         this.activeItem = this.activeItem === this.itemCount - 1 ? 0 : this.activeItem + 1;
// //       };

// //       this.prev = function() {
// //         this.activeItem = this.activeItem || 0;
// //         this.activeItem = this.activeItem === 0 ? this.itemCount - 1 : this.activeItem - 1;
// //       };
// //     }
// //   };
// // });

// // portfolio.directive('card', function($drag) {
// //   return {
// //     restrict: 'C',
// //     require: '^cards',
// //     scope: {},
// //     transclude: true,
// //     template: '<div class="item"><div ng-transclude></div></div>',
// //     link: function(scope, elem, attrs, carousel) {
// //       scope.carousel = carousel;
// //       var id = carousel.addItem();

// //       var zIndex = function() {
// //         var res = 0;
// //         if (id === carousel.activeItem) {
// //           res = 2000;
// //         } else if (carousel.activeItem < id) {
// //           res = 2000 - (id - carousel.activeItem);
// //         } else {
// //           res = 2000 - (carousel.itemCount - 1 - carousel.activeItem + id);
// //         }
// //         return res;
// //       };

// //       scope.$watch(function() {
// //         return carousel.activeItem;
// //       }, function() {
// //         elem[0].style.zIndex = zIndex();
// //       });

// //       $drag.bind(elem, {
// //         //
// //         // This is an example of custom transform function
// //         //
// //         transform: function(element, transform, touch) {
// //           //
// //           // use translate both as basis for the new transform:
// //           //
// //           var t = $drag.TRANSLATE_BOTH(element, transform, touch);

// //           //
// //           // Add rotation:
// //           //
// //           var Dx    = touch.distanceX;
// //           var t0    = touch.startTransform;
// //           var sign  = Dx < 0 ? -1 : 1;
// //           var angle = sign * Math.min((Math.abs(Dx) / 700) * 30 , 30);

// //           t.rotateZ = angle + (Math.round(t0.rotateZ));

// //           return t;
// //         },
// //         move: function(drag) {
// //           if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
// //             elem.addClass('dismiss');
// //           } else {
// //             elem.removeClass('dismiss');
// //           }
// //         },
// //         cancel: function() {
// //           elem.removeClass('dismiss');
// //         },
// //         end: function(drag) {
// //           elem.removeClass('dismiss');
// //           if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
// //             scope.$apply(function() {
// //               carousel.next();
// //             });
// //           }
// //           drag.reset();
// //         }
// //       });
// //     }
// //   };
// // });
// portfolio.directive('hmDir', ['$timeout', '$http', 'projectsService',
// 	function($timeout, $http, projectsService) {
// 		return {
// 			restrict: 'AE',
// 			controller: 'PortfolioController',
// 			scope: true,
// 			// scope: {
// 			// 	'spark': '=project',
// 			// 	'neroli': '=project'
// 			// },
// 			link: (scope, element, attrs, controller) => {
// 				// console.log(attrs);

// 			},
// 			compile: function(tElem, tAttrs) {
// 				return {
// 					pre: function(scope, iElem, iAttrs) {
// 						console.log(scope);
// 						// scope.$watch('project', function(value) {
// 						// 	// setInterval(()=>{console.log(value);},1000);

// 						// 	projectsService.canAddMethods().then(() => {

// 						// 		var computedPosition, top, left, card, cardHeight;

// 						// 		// console.log(iElem[0].getElementsByClassName('card')[0]);
// 						// 		card = iElem[0].getElementsByClassName('card')[0];
// 						// 		// console.log(card);
// 						// 		cardHeight = card.offsetHeight;
// 						// 		// console.log(card.getBoundingClientRect());
// 						// 		computedPosition = card.getBoundingClientRect();
// 						// 		$timeout(() => {
// 						// 			// computedPosition = card.getBoundingClientRect(),
// 						// 			top = computedPosition.top - cardHeight,
// 						// 				left = computedPosition.left;
// 						// 		});

// 						// 		// console.log(scope.projects);
// 						// 		// console.log(iAttrs.project);
// 						// 		// console.log(scope.projects[iAttrs.project]);
// 						// 		// console.log(scope.projects);
// 						// 		value.hammer = {
// 						// 			onPan: event => {
// 						// 				console.log(event);
// 						// 				if (event.target === card) {
// 						// 					// scope[key].dragging = true;
// 						// 					iElem.children().css({
// 						// 						'left': left + event.deltaX + 'px',
// 						// 						'top': top - cardHeight + event.deltaY + 'px'
// 						// 					});
// 						// 				}
// 						// 			},
// 						// 			endPan: event => {
// 						// 				computedPosition = card.getBoundingClientRect(),
// 						// 					top = computedPosition.top - cardHeight,
// 						// 					left = computedPosition.left;
// 						// 				// scope[key].dragging = false;
// 						// 			},
// 						// 			swipeRight: event => {
// 						// 				// console.log('swiped',event);
// 						// 			}
// 						// 		};
// 						// 		// console.log(scope.projects[iAttrs.project]);

// 						// 		 // hm-panmove="{{project.hammer.onPan}}" hm-panend="{{project_name}}.hammer.endPan" hm-swiperight="project.hammer.swipeRight"

// 						// 		// console.log(iElem);
// 						// 		console.log(scope);
// 						// 		// iElem.val('hm-panmove',)

// 						// 	});

// 						// });

// 						projectsService.canAddMethods().then(() => {
// 							$timeout(() => {
// 								// var computedPosition, top, left, card, cardHeight;

// 								// // console.log(iElem[0].getElementsByClassName('card')[0]);
// 								// card = iElem[0].getElementsByClassName('card')[0];
// 								// // console.log(card);
// 								// cardHeight = card.offsetHeight;
// 								// // console.log(card.getBoundingClientRect());
// 								// computedPosition = card.getBoundingClientRect();
// 								// $timeout(() => {
// 								// 	// computedPosition = card.getBoundingClientRect(),
// 								// 	top = computedPosition.top - cardHeight,
// 								// 		left = computedPosition.left;
// 								// });

// 								// // console.log(scope.projects);
// 								// // console.log(iAttrs.project);
// 								// // console.log(scope.projects[iAttrs.project]);
// 								// scope.projects[iAttrs.project].hammer = {
// 								// 	onPan: event => {
// 								// 		console.log(event);
// 								// 		if (event.target === card) {
// 								// 			// scope[key].dragging = true;
// 								// 			iElem.children().css({
// 								// 				'left': left + event.deltaX + 'px',
// 								// 				'top': top - cardHeight + event.deltaY + 'px'
// 								// 			});
// 								// 		}
// 								// 	},
// 								// 	endPan: event => {
// 								// 		computedPosition = card.getBoundingClientRect(),
// 								// 			top = computedPosition.top - cardHeight,
// 								// 			left = computedPosition.left;
// 								// 		// scope[key].dragging = false;
// 								// 	},
// 								// 	swipeRight: event => {
// 								// 		// console.log('swiped',event);
// 								// 	}
// 								// };
// 								// console.log(scope.projects[iAttrs.project]);
// 							});
// 						});

// 					}

// 					/*,
// 					post: function(scope, iElem, iAttrs) {
// 						// each card needs its own Hammer functions
// 						Object.keys(scope).forEach(function(key, index) {
// 							if (key == iAttrs.project) {
// 								var computedPosition, top, left, card, cardContentHeight;
// 								card = iElem[0].getElementsByClassName('card')[0],
// 								cardContentHeight = card.querySelector('.card-content').offsetHeight;
// 								// console.log(card.getBoundingClientRect());
// 								computedPosition = card.getBoundingClientRect();
// 								$timeout(() => {
// 									// computedPosition = card.getBoundingClientRect(),
// 									top = computedPosition.top - cardContentHeight,
// 									left = computedPosition.left;
// 									// console.log(computedPosition);
// 								});
// 								scope[key] = {
// 									dragging: false,
// 									onPan: event => {
// 										if (event.target === card) {
// 											// scope[key].dragging = true;
// 											iElem.children().css({
// 												'left': left + event.deltaX + 'px',
// 												'top': top - cardContentHeight + event.deltaY + 'px'
// 											});
// 										}
// 									},
// 									endPan: event => {
// 										computedPosition = card.getBoundingClientRect(),
// 										top = computedPosition.top - cardContentHeight,
// 										left = computedPosition.left;
// 										// scope[key].dragging = false;
// 									},
// 									swipeRight: event => {
// 										// console.log('swiped',event);
// 									}
// 								};

// 							}
// 						});
// 					}
// 					*/
// 				}
// 			}

// 		}
// 	}
// ]);

portfolio.directive('card', ['$drag', '$touch', 'projectsService', function ($drag, $touch, projectsService) {
	return {
		restrict: 'C',
		transclude: true,
		template: '<div class="project"><div ng-transclude></div></div>',
		controller: 'PortfolioController',
		// require: '^PortfolioController',
		link: function link(scope, elem, attrs, PortfolioController) {

			var id, index, zIndex, zIndexDelta;
			id = index = projectsService.addCard();
			zIndexDelta = 0;
			zIndex = elem[0].style.zIndex;

			scope.$watch(function () {
				return projectsService.activeCard();
			}, function () {
				//update zindex
				zIndexDelta = 0;
				if (id === projectsService.activeCard()) zIndexDelta = 0;else if (projectsService.activeCard() < id) zIndexDelta = id - projectsService.activeCard();else zIndexDelta = projectsService.cardCount() - 1 - projectsService.activeCard() + id;
				elem[0].style.zIndex = 2000 - zIndexDelta;

				//update width and position from top
				if (index < 0) index = projectsService.cardCount() - 1;
				index--;
				elem[0].style.width = 100 - (index + 1) + '%';
				elem[0].style.top = projectsService.cardSpreadInterval() * (index + 1) + 'px';
			});

			$drag.bind(elem, {
				transform: function transform(element, _transform, touch) {
					var t = $drag.TRANSLATE_BOTH(element, _transform, touch),
					    Dx = touch.distanceX,
					    t0 = touch.startTransform,
					    sign = Dx < 0 ? -1 : 1,
					    angle = sign * Math.min(Math.abs(Dx) / 700 * 30, 30);

					t.rotateZ = angle + Math.round(t0.rotateZ);
					return t;
				},
				start: function start(drag, event) {
					event.stopPropagation();
					PortfolioController.scrollableToggle(false);
				},
				move: function move(drag, event) {
					event.stopPropagation();
					elem[0].style.opacity = 1 - Math.abs(drag.distanceX) / drag.rect.width;
					if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
						elem.addClass('dismiss');
					} else {
						elem.removeClass('dismiss');
					}
				},
				cancel: function cancel() {
					elem.removeClass('dismiss');
				},
				end: function end(drag) {
					elem[0].style.opacity = 1;
					PortfolioController.scrollableToggle(true);
					elem.removeClass('dismiss');
					if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
						scope.$apply(function () {
							projectsService.next();
						});
					}
					drag.reset();
				}
			});

			$touch.bind(elem, {
				end: function end(touchInfo, event) {
					if (Math.abs(touchInfo.total) < elem[0].clientWidth / 8) {
						var flipCard = elem[0].querySelector('.flip-card');
						flipCard.classList.toggle('flipped');
					}
				}
			});
		}
	};
}]);