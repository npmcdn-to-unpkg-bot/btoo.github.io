'use strict';

var portfolio = angular.module('portfolio', ['ngAnimate', 'ngSanitize', 'mobile-angular-ui', 'mobile-angular-ui.gestures.drag', 'ngAnimate', 'ngSanitize', 'duScroll'])
// these values are configuration settings for angular-scroll
// .value('duScrollEasing', x => {
// 	return 1-x;
// })
.value('duScrollOffset', 88);
portfolio.factory('landingService', ['$q', function ($q) {

	// animated the B
	var _animatedB = $q.defer();
	// animatedB.promise.then(console.log('resolved animatedB'));

	// created the squares
	var _createdSquares = $q.defer();

	// finished animating B and creating squares, so animate the squares
	var requiredForAnimatingSquares = [_animatedB.promise, _createdSquares.promise];

	// animated squares
	var _animatedSquares = $q.defer();

	// animated the card
	// this.animatedCard = $q.defer();
	// this.animatedCard.promise

	// var qlandingAnimated = $q.defer();
	// var plandingAnimated = qlandingAnimated.promise;

	return {
		'animatedB': function animatedB() {
			return _animatedB.resolve();
		},
		'createdSquares': function createdSquares() {
			return _createdSquares.resolve();
		},
		'canAnimateSquares': function canAnimateSquares() {
			return $q.all(requiredForAnimatingSquares);
		},
		'animatedSquares': function animatedSquares() {
			return _animatedSquares.resolve();
		},
		'canAnimateCard': function canAnimateCard() {
			return _animatedSquares.promise;
		}
	};
}]);
portfolio.factory('projectsService', ['$q', '$http', function ($q, $http) {

	var _loadedProjects = $q.defer();
	// loadedProjects.promise.then(() => {

	// });

	var _cardCount = 0;
	var _activeCard = null;

	return {
		'loadedProjects': function loadedProjects() {
			_loadedProjects.resolve();
		},
		'canAddMethods': function canAddMethods() {
			return _loadedProjects.promise;
		},

		cardCount: function cardCount() {
			return _cardCount;
		},
		activeCard: function activeCard() {
			return _activeCard;
		},
		addCard: function addCard() {
			var newId = _cardCount++;
			_activeCard = _cardCount === 1 ? newId : _activeCard;
			return newId;
		},
		next: function next() {
			_activeCard = _activeCard || 0;
			_activeCard = _activeCard === _cardCount - 1 ? 0 : _activeCard + 1;
		},
		prev: function prev() {
			_activeCard = _activeCard || 0;
			_activeCard = _activeCard === 0 ? _cardCount - 1 : _activeCard - 1;
		}
	};
}]);
// portfolio.controller('LandingController', function($scope, landingService, ){

// });
portfolio.controller('PortfolioController', ['$scope', '$http', '$window', 'projectsService', '$location', '$anchorScroll', '$document', /*"uiGmapGoogleMapApi", "ColorService", 'ScrollService',*/
function ($scope, $http, $window, projectsService, $location, $anchorScroll, $document /*, uiGmapGoogleMapApi, ColorService, ScrollService*/) {
	var _this = this;

	var self = this;

	$scope.projects = {};
	// ProjectsService.loadProjectsInto($scope.projects);
	$http.get('resources/json/projects.json').then(function (response) {
		// console.log(response.data);
		$scope.projects = response.data;
		projectsService.loadedProjects();
	});

	var birthdate = moment("1993-08-24 00:00").startOf('minute');
	this.ageyears = moment().diff(birthdate, 'years');
	this.agemonths = moment().subtract(this.ageyears, 'years').diff(birthdate, 'months');
	this.ageseconds = moment().subtract(this.ageyears, 'years').subtract(this.agemonths, 'months').diff(birthdate, 'seconds');
	setInterval(function () {
		return $scope.$apply(function () {
			return _this.ageseconds++;
		} //make me older by a second every second
		);
	}, 1000);

	function landingScroll() {
		var windowTopHTML = $("html").scrollTop();
		var windowTopBody = $("body").scrollTop();
		var windowTop = Math.max(windowTopHTML, windowTopBody);
		if (windowTop > 50) {
			$('.landing-background').removeClass('navbar');
			$('landing-card').addClass('navbar');
		} else {
			$('.landing-background').addClass('navbar');
			$('landing-card').removeClass('navbar');
		}
	}

	this.initialScroll = function () {
		console.log('scrolling');
		$scope.scrollable = 'scrollable';
		var top = 0;
		if ($('#intro').offset().top - 120 + $('#intro')[0].offsetHeight - $(window).height() > $('#intro').offset().top) {
			top = $('#intro').offset().top - 120;
		} else {
			top = $('#intro').offset().top + $('#intro')[0].offsetHeight - $(window).height();
		}
		$("html, body").stop().animate({
			scrollTop: top
		}, 800);
	};

	$scope.goToSecond = function () {
		// $location.hash('second');
		// $anchorScroll();
		$document.scrollToElementAnimated(angular.element(document.getElementById('second')));
	};

	$scope.showLandingContent = false;
	$scope.scrollable = 'scrollable';
	this.scrollableToggle = function (state) {
		$scope.scrollable = state ? 'scrollable' : 'unscrollable';
		// console.log($scope.scrollable);
	};

	angular.element($window).bind( //when user reaches bottom of page
	"scroll", function () {
		var windowHeight = "innerHeight" in window ? window.innerHeight : document.documentElement.offsetHeight;
		var body = document.body,
		    html = document.documentElement;
		var docHeight = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
		var windowBottom = windowHeight + window.pageYOffset;
		if (windowBottom >= docHeight) {
			// alert('bottom reached');
			console.log('bottom reached');
			// self.scrollableToggle(false);
		}
	});
}]);
portfolio.directive('animejsBanner', ['$q', 'landingService', /*"ColorService",*/
function ($q, landingService /*,ColorService*/) {
	return {
		restrict: 'AE',
		templateUrl: 'js/directives/animejs-banner/animejs-banner.html',
		controller: 'PortfolioController',
		link: function link(scope, element, attr, ctrl) {

			// animate the B
			var loadingSquares = element[0].querySelector('#loading-squares');
			anime({
				targets: '#Bsvg path',
				strokeDashoffset: {
					easing: 'easeInOutExpo',
					duration: 500,
					value: function value(el) {
						var pathLength = el.getTotalLength();
						el.setAttribute('stroke-dasharray', pathLength);
						return [-pathLength, 0];
					}
				},
				stroke: {
					value: function value(el, i) {
						return 'rgb(' + i * 2 + ',' + i * 8 + ',' + i * 12 + ')';
					},
					easing: 'linear',
					duration: 222
				},
				strokeWidth: {
					value: 8,
					easing: 'linear',
					delay: function delay(el, i) {
						return 600 + i * 8;
					},
					duration: 222
				},
				delay: function delay(el, i) {
					return i * 30;
				},
				duration: 1200,
				easing: 'easeOutExpo',
				loop: false,
				direction: 'alternate',
				update: function update(animation) {
					//start animating squares once B is loaded
					if (animation.reversed == true) landingService.animatedB();
				},
				complete: function complete() {
					// console.log('finished loadingscreen');
				}
			});

			// create the elements for the squares
			var squares = element[0].querySelector('#squares');
			var x, y, xmax, ymin, xincrement, yincrement;
			x = y = xmax = ymin = 0;
			var size = Math.min(Math.ceil(element.height() / 3.8), 122);
			xincrement = yincrement = size; //width and height of each square
			do {
				squares.innerHTML += '\n\t\t\t\t\t\t\t\t\t\t\t\t<article style="width:' + xincrement + 'px;height:' + yincrement + 'px;top:' + y + 'px;right:' + x + 'px">\n\t\t\t\t\t\t\t\t\t\t\t\t\t<div></div>\n\t\t\t\t\t\t\t\t\t\t\t\t</article>\n\t\t\t\t\t\t\t\t\t\t\t';

				if (x < xincrement || y > element.height() - yincrement) {
					if (xmax < element.width()) {
						xmax += xincrement;
					} else {
						ymin += yincrement;
					}
					y = ymin;
					x = xmax;
				} else {
					x -= xincrement;
					y += yincrement;
				}
			} while (x < element.width() || y < element.height());
			$('#squares').css('display', 'block');
			// console.log('finished building squares');
			landingService.createdSquares();

			// B is animated AND squares are created
			landingService.canAnimateSquares().then(function () {
				anime({
					targets: '#squares div',
					rotate: {
						value: 180,
						duration: 888,
						easing: 'easeInOutQuad'
					},
					scale: {
						value: [0, 1],
						// delay: 150,
						duration: 888,
						easing: 'easeInOutExpo'
					},
					loop: false,
					direction: 'normal',
					borderRadius: {
						value: 0,
						duration: 1222,
						easing: 'easeInOutCirc'
						// easing: 'linear'
					},
					backgroundColor: '#18212D',
					delay: function delay(el, index, total) {
						var duration = 888; //duration of squares animation
						return index * (duration / total);
					},
					update: function update(animation) {
						if (animation.progress > 75) landingService.animatedSquares();
					},
					complete: function complete() {
						squares.className += 'bg-dark';
						element.find('article').hide();
					}
				});
			});
		}
	};
}]);

portfolio.directive("bubbleGradient", [/*"ColorService",*/
function () /*ColorService*/{
	return {
		restrict: 'AE',
		// templateUrl: 'js/directives/bubble-gradient/bubble-gradient.html',
		link: function link(scope, element, attr, ctrl) {

			var bg = $('<canvas id="bubble-gradient" width="' + element.width() + '" height="' + element.height() + '"></canvas>').css({
				'z-index': 0,
				'position': 'absolute'
			});
			element.append(bg);

			console.log(scope, element, this);
			var mainCanvas = document.querySelector("#bubble-gradient");
			var mainContext = mainCanvas.getContext("2d");

			var canvasWidth = mainCanvas.width;
			var canvasHeight = mainCanvas.height;

			// empty the canvas
			mainContext.clearRect(0, 0, canvasWidth, canvasHeight);

			// color in the background of the canvas
			mainContext.fillStyle = "#EEEEEE";
			mainContext.fillRect(0, 0, canvasWidth, canvasHeight);

			var Circle = function Circle(x, y, full) {
				//x,y distance from top right; full is radius when fully grown
				this.x = x;
				this.y = y;
				this.radius = 0;
				this.angle = 0;
				this.full = full;
			};
			Circle.prototype.grow = function () {
				mainContext.beginPath();

				this.radius = this.full * Math.abs(Math.sin(this.angle));
				mainContext.arc(canvasWidth - this.x, this.y, this.radius, 0, Math.PI * 2, false);
				mainContext.closePath();

				// color in the circle
				mainContext.fillStyle = "#006699";
				mainContext.fill();

				this.angle += .01;

				// circle has not reached full radius length
				if (this.radius < this.full) return false;else return true;
			};

			var x, y, xmax, ymin, interval, xincrement, yincrement;
			x = y = xmax = ymin = 0;
			interval = 10;
			xincrement = canvasHeight / 5;
			yincrement = canvasHeight / 5;
			var bubble = setInterval(function () {
				var circle = new Circle(x, y, canvasWidth / 5);
				var animateCircle = setInterval(function () {
					if (circle.grow()) clearInterval(animateCircle);
				}, 1);

				if (x >= canvasWidth && y >= canvasHeight) {
					//filled up canvas
					console.log('stopping');
					clearInterval(bubble);
				} else if (x <= 0 || y >= canvasHeight) {
					if (xmax < canvasWidth) {
						xincrement -= 5;
						xmax += xincrement;
					} else {
						ymin += yincrement;
					}
					y = ymin;
					x = xmax;
				} else {
					x -= xincrement;
					y += yincrement;
				}

				// interval+=10;
				// if(interval>2) interval--;
			}, interval);
		}
	};
}]);

portfolio.directive('landingContent', ['landingService', /*'ColorService', */
function (landingService /*ColorService*/) {
	return {
		restrict: 'AE',
		templateUrl: 'js/directives/landing-content/landing-content.html',
		scope: false, //use scope from PortfolioController
		link: function link(scope, element, attr, ctrl) {

			// finished animating squares, so animate landing card
			landingService.canAnimateCard().then(function () {
				console.log('finished animating squares, so now animate the card');

				scope.showLandingContent = true;
			});
		}
	};
}]);

portfolio.directive('hmDir', ['$timeout', '$http', 'projectsService', function ($timeout, $http, projectsService) {
	return {
		restrict: 'AE',
		controller: 'PortfolioController',
		scope: true,
		// scope: {
		// 	'spark': '=project',
		// 	'neroli': '=project'
		// },
		link: function link(scope, element, attrs, controller) {
			// console.log(attrs);

		},
		compile: function compile(tElem, tAttrs) {
			return {
				pre: function pre(scope, iElem, iAttrs) {
					console.log(scope);
					// scope.$watch('project', function(value) {
					// 	// setInterval(()=>{console.log(value);},1000);

					// 	projectsService.canAddMethods().then(() => {

					// 		var computedPosition, top, left, card, cardHeight;

					// 		// console.log(iElem[0].getElementsByClassName('card')[0]);
					// 		card = iElem[0].getElementsByClassName('card')[0];
					// 		// console.log(card);
					// 		cardHeight = card.offsetHeight;
					// 		// console.log(card.getBoundingClientRect());
					// 		computedPosition = card.getBoundingClientRect();
					// 		$timeout(() => {
					// 			// computedPosition = card.getBoundingClientRect(),
					// 			top = computedPosition.top - cardHeight,
					// 				left = computedPosition.left;
					// 		});

					// 		// console.log(scope.projects);
					// 		// console.log(iAttrs.project);
					// 		// console.log(scope.projects[iAttrs.project]);
					// 		// console.log(scope.projects);
					// 		value.hammer = {
					// 			onPan: event => {
					// 				console.log(event);
					// 				if (event.target === card) {
					// 					// scope[key].dragging = true;
					// 					iElem.children().css({
					// 						'left': left + event.deltaX + 'px',
					// 						'top': top - cardHeight + event.deltaY + 'px'
					// 					});
					// 				}
					// 			},
					// 			endPan: event => {
					// 				computedPosition = card.getBoundingClientRect(),
					// 					top = computedPosition.top - cardHeight,
					// 					left = computedPosition.left;
					// 				// scope[key].dragging = false;
					// 			},
					// 			swipeRight: event => {
					// 				// console.log('swiped',event);
					// 			}
					// 		};
					// 		// console.log(scope.projects[iAttrs.project]);

					// 		 // hm-panmove="{{project.hammer.onPan}}" hm-panend="{{project_name}}.hammer.endPan" hm-swiperight="project.hammer.swipeRight"

					// 		// console.log(iElem);
					// 		console.log(scope);
					// 		// iElem.val('hm-panmove',)

					// 	});

					// });

					projectsService.canAddMethods().then(function () {
						$timeout(function () {
							// var computedPosition, top, left, card, cardHeight;

							// // console.log(iElem[0].getElementsByClassName('card')[0]);
							// card = iElem[0].getElementsByClassName('card')[0];
							// // console.log(card);
							// cardHeight = card.offsetHeight;
							// // console.log(card.getBoundingClientRect());
							// computedPosition = card.getBoundingClientRect();
							// $timeout(() => {
							// 	// computedPosition = card.getBoundingClientRect(),
							// 	top = computedPosition.top - cardHeight,
							// 		left = computedPosition.left;
							// });

							// // console.log(scope.projects);
							// // console.log(iAttrs.project);
							// // console.log(scope.projects[iAttrs.project]);
							// scope.projects[iAttrs.project].hammer = {
							// 	onPan: event => {
							// 		console.log(event);
							// 		if (event.target === card) {
							// 			// scope[key].dragging = true;
							// 			iElem.children().css({
							// 				'left': left + event.deltaX + 'px',
							// 				'top': top - cardHeight + event.deltaY + 'px'
							// 			});
							// 		}
							// 	},
							// 	endPan: event => {
							// 		computedPosition = card.getBoundingClientRect(),
							// 			top = computedPosition.top - cardHeight,
							// 			left = computedPosition.left;
							// 		// scope[key].dragging = false;
							// 	},
							// 	swipeRight: event => {
							// 		// console.log('swiped',event);
							// 	}
							// };
							// console.log(scope.projects[iAttrs.project]);
						});
					});
				}

				/*,
    post: function(scope, iElem, iAttrs) {
    	// each card needs its own Hammer functions
    	Object.keys(scope).forEach(function(key, index) {
    		if (key == iAttrs.project) {
    			var computedPosition, top, left, card, cardContentHeight;
    			card = iElem[0].getElementsByClassName('card')[0],
    			cardContentHeight = card.querySelector('.card-content').offsetHeight;
    			// console.log(card.getBoundingClientRect());
    			computedPosition = card.getBoundingClientRect();
    			$timeout(() => {
    				// computedPosition = card.getBoundingClientRect(),
    				top = computedPosition.top - cardContentHeight,
    				left = computedPosition.left;
    				// console.log(computedPosition);
    			});
    			scope[key] = {
    				dragging: false,
    				onPan: event => {
    					if (event.target === card) {
    						// scope[key].dragging = true;
    						iElem.children().css({
    							'left': left + event.deltaX + 'px',
    							'top': top - cardContentHeight + event.deltaY + 'px'
    						});
    					}
    				},
    				endPan: event => {
    					computedPosition = card.getBoundingClientRect(),
    					top = computedPosition.top - cardContentHeight,
    					left = computedPosition.left;
    					// scope[key].dragging = false;
    				},
    				swipeRight: event => {
    					// console.log('swiped',event);
    				}
    			};
    				}
    	});
    }
    */
			};
		}

	};
}]);

portfolio.directive('card', ['$drag', 'projectsService', function ($drag, projectsService) {
	return {
		restrict: 'C',
		transclude: true,
		template: '<div class="project"><div ng-transclude></div></div>',

		// these added to test out ng-repeat with ng-transclude			
		// transclude: 'element',
		// replace: true,
		// scope: true,
		// template: [
		// 	''
		// ],

		controller: 'PortfolioController',
		// require: '^PortfolioController',
		link: function link(scope, elem, attrs, PortfolioController) {

			// console.log(scope);
			var id = projectsService.addCard();
			// console.log(elem[0], id);
			var zIndex = function zIndex() {
				var res = 0;
				if (id === projectsService.activeCard()) {
					res = 2000;
				} else if (projectsService.activeCard() < id) {
					res = 2000 - (id - projectsService.activeCard());
				} else {
					res = 2000 - (projectsService.cardCount() - 1 - projectsService.activeCard() + id);
				}
				return res;
			};

			scope.$watch(function () {
				return projectsService.activeCard();
			}, function () {
				elem[0].style.zIndex = zIndex();
			});

			$drag.bind(elem, {
				transform: function transform(element, _transform, touch) {
					var t = $drag.TRANSLATE_BOTH(element, _transform, touch),
					    Dx = touch.distanceX,
					    t0 = touch.startTransform,
					    sign = Dx < 0 ? -1 : 1,
					    angle = sign * Math.min(Math.abs(Dx) / 700 * 30, 30);

					t.rotateZ = angle + Math.round(t0.rotateZ);
					return t;
				},
				start: function start(drag, event) {
					event.stopPropagation();
					PortfolioController.scrollableToggle(false);
				},
				move: function move(drag, event) {
					event.stopPropagation();
					if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
						elem.addClass('dismiss');
					} else {
						elem.removeClass('dismiss');
					}
				},
				cancel: function cancel() {
					elem.removeClass('dismiss');
				},
				end: function end(drag) {
					PortfolioController.scrollableToggle(true);
					elem.removeClass('dismiss');
					if (Math.abs(drag.distanceX) >= drag.rect.width / 4) {
						console.log('is greater');
						scope.$apply(function () {
							projectsService.next();
						});
					}
					drag.reset();
				}
			});
		}
	};
}]);